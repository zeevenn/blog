import{_ as n,c as a,e as s,o as t}from"./app-DjQQUbip.js";const o={};function c(p,e){return t(),a("div",null,[...e[0]||(e[0]=[s(`<h2 id="usememo" tabindex="-1"><a class="header-anchor" href="#usememo"><span>useMemo</span></a></h2><p><code>useMemo</code> 可以缓存一个函数的结果，避免重复计算。</p><div class="language-tsx line-numbers-mode" data-ext="tsx" data-title="tsx"><pre class="language-tsx"><code><span class="token keyword">const</span> memoizedValue <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">expensiveCalculation</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>useMemo</code> 接收两个参数：</p><ul><li><code>callback</code>：一个函数，返回一个值。</li><li><code>dependencies</code>：一个数组，包含所有依赖项。当依赖项发生变化时，<code>callback</code> 函数会重新执行。</li></ul><p><code>useMemo</code> 会返回一个 memoized 值，当依赖项发生变化时，<code>callback</code> 函数会重新执行，并返回新的值。</p><p>大部分情况下，React Compiler 会自动优化性能，只有在计算过程耗时较长导致交互明显卡顿的情况下，才有可能需要使用 <code>useMemo</code>。</p><p>当你需要缓存一个函数时，可以这样使用：</p><div class="language-tsx line-numbers-mode" data-ext="tsx" data-title="tsx"><pre class="language-tsx"><code><span class="token keyword">const</span> memoizedFunction <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;memoized function&#39;</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>缓存函数的情况非常常见，因此 react 提供了 <code>useCallback</code> 钩子来避免嵌套。</p><h2 id="usecallback" tabindex="-1"><a class="header-anchor" href="#usecallback"><span>useCallback</span></a></h2><p><code>useCallback</code> 可以缓存一个函数，避免重复创建。<code>useCallback</code> 接收两个参数：</p><ul><li><code>callback</code>：一个函数，返回一个值。</li><li><code>dependencies</code>：一个数组，包含所有依赖项。当依赖项发生变化时，<code>callback</code> 函数会重新执行。</li></ul><div class="language-tsx line-numbers-mode" data-ext="tsx" data-title="tsx"><pre class="language-tsx"><code><span class="token keyword">const</span> memoizedFunction <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;memoized function&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="memo" tabindex="-1"><a class="header-anchor" href="#memo"><span>memo</span></a></h2><p><code>memo</code> 可以缓存一个组件，避免重复渲染。<code>memo</code> 接收两个参数：</p><ul><li><code>component</code>：一个组件，返回一个值。</li><li><code>arePropsEqual</code>：可选值，一个函数，接收两个参数，<code>prevProps</code> 和 <code>nextProps</code>，当 <code>prevProps</code> 和 <code>nextProps</code> 相等时，组件不会重新渲染，通常情况下，你不需要手动进行比较，默认情况下，<code>memo</code> 会使用 <code>Object.is</code> 进行比较。</li></ul><div class="language-tsx line-numbers-mode" data-ext="tsx" data-title="tsx"><pre class="language-tsx"><code><span class="token keyword">const</span> MemoizedComponent <span class="token operator">=</span> <span class="token function">memo</span><span class="token punctuation">(</span>SomeComponent<span class="token punctuation">,</span> arePropsEqual<span class="token operator">?</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,18)])])}const i=n(o,[["render",c],["__file","14-useMemo-useCallback-memo.html.vue"]]),u=JSON.parse('{"path":"/frontend/framework/react/14-useMemo-useCallback-memo.html","title":"useMemo & useCallback & memo","lang":"zh-CN","frontmatter":{"title":"useMemo & useCallback & memo","tag":["react","hooks"],"description":"useMemo useMemo 可以缓存一个函数的结果，避免重复计算。 useMemo 接收两个参数： callback：一个函数，返回一个值。 dependencies：一个数组，包含所有依赖项。当依赖项发生变化时，callback 函数会重新执行。 useMemo 会返回一个 memoized 值，当依赖项发生变化时，callback 函数会重新执...","head":[["meta",{"property":"og:url","content":"https://dribble-njr.github.io/blog/blog/frontend/framework/react/14-useMemo-useCallback-memo.html"}],["meta",{"property":"og:title","content":"useMemo & useCallback & memo"}],["meta",{"property":"og:description","content":"useMemo useMemo 可以缓存一个函数的结果，避免重复计算。 useMemo 接收两个参数： callback：一个函数，返回一个值。 dependencies：一个数组，包含所有依赖项。当依赖项发生变化时，callback 函数会重新执行。 useMemo 会返回一个 memoized 值，当依赖项发生变化时，callback 函数会重新执..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-05T09:11:09.000Z"}],["meta",{"property":"article:author","content":"njr"}],["meta",{"property":"article:tag","content":"react"}],["meta",{"property":"article:tag","content":"hooks"}],["meta",{"property":"article:modified_time","content":"2025-09-05T09:11:09.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"useMemo & useCallback & memo\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-09-05T09:11:09.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"njr\\",\\"url\\":\\"https://github.com/dribble-njr/blog\\",\\"email\\":\\"wzw15292257101@163.com\\"}]}"]]},"headers":[{"level":2,"title":"1 useMemo","slug":"usememo","link":"#usememo","children":[]},{"level":2,"title":"2 useCallback","slug":"usecallback","link":"#usecallback","children":[]},{"level":2,"title":"3 memo","slug":"memo","link":"#memo","children":[]}],"git":{"createdTime":1757063469000,"updatedTime":1757063469000,"contributors":[{"name":"Ziven","email":"contact@ziven.me","commits":1}]},"readingTime":{"minutes":1.26,"words":379},"filePathRelative":"frontend/framework/react/14-useMemo-useCallback-memo.md","localizedDate":"2025年9月5日","excerpt":"","autoDesc":true}');export{i as comp,u as data};
